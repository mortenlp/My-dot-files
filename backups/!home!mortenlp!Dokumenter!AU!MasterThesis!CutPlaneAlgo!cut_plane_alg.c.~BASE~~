/* ----------------------------------------------------------------------
   This program features an implementation of a cutting plane algorithm
   aimed at optimizing over the splitclosure of a given polyhedron. The
   difference from the program of Balas and Saxena (2008) is mainly the
   use of basic polyhedra instead of just considering the lp-polyhedron.
   ----------------------------------------------------------------------
   Author: Morten Leander Petersen
   ----------------------------------------------------------------------
   Note: This particular file (cut_plane_alg.c) was originally written
   by Kent Andersen, but is now heavily modified.
   ----------------------------------------------------------------------
   Note: cut_stuff.c, cut_stuff.h, lp_stuff.c and lp_stuff.h is authored
   by Kent Andersen
   ---------------------------------------------------------------------- */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <signal.h>

#include "lp_stuff.h"
#include "cut_stuff.h"
#include "splitcut.h"

int MAX_NZ      =8000000;    /* Maximum number of nonzeros in an LP
                                that we allow. */
int MAX_NROW    =10000;      /* Maximum number of constraints we allow. */
int i,j;                     /* Iterators */

int main(int argc, char *argv[])
{
  /* Data describing sizes of the LP/MIP. */
  int ncol;  /* Number of variables. */
  int nrow;  /* Number of constraints. */
  int nnz;   /* Number of non-zeros. */

  /* Solution data. */
  double  *lp_sol= NULL;      /* Solution to the LP-relaxation. */
  int     *rowstat= NULL;     /* Whether a constraint is basic/non-basic. */
  int     *colstat= NULL;     /* Whether a variable is basic/non-basic. */
  double objval;             /* The objective value of the LP relaxation. */
  double *objval_pmilp = NULL;  /* The objective value of the PMILP */

  /* CPLEX structures. */
  CPXENVptr env= NULL;        /* CPLEX enviroment. */
  CPXLPptr  lp= NULL;         /* Pointer to the problem we are solving
                                 within this enviroment. */
  CPXLPptr  mip = NULL;         /* Pointer to the object which stores the PMILP */

  /* Structure for storing MILP problem. */
  struct mip_struct problem;

  /* Structure to hold the parametric MIP */
  struct mip_struct pmilp;

  /* Structure to hold the cuts in each iteration */
  struct cut_struct cuts;

  int MAX_NCUTS;      /* Maximum number of cuts allowed. */
  int MAX_NZCUTS;     /* Maximum number of non-zeros in the cuts that we allow. */

  /* Misc. data. */
  int status = 0;

  double grid_interval;    /* Step length, when going through the grid */

  double start;            /* Tells where theta should start */
  int count;                  /* Used when enriching the grid */
  double theta;           /* Parameter of the PMILP */
  int no_grid_enrich;         /* Counts the no. of times the grid has
                                     been enriched */

  int run = 1;                    /* The loop runs as long as run!=0 */
  int solstat = 0;                /* Used to check wether a solution
                                     exists or not */
  double constant;                /* Constant part of the objective funtion of PMILP */

  double *pi = NULL;                    /* Array to store solution of pmilp */
  double *cut = NULL;                   /* Stores, in each iteration, the splitcuts generated */
  double *cut_rhs = NULL;               /* Stores the right-hand-side
                                           of the cut */

  /* Input file. */
  char *filename= NULL;

  /* Must parse a filename to the program. */
  if( argc != 2 )
    {
      printf("syntax: filename needs to be specified...\n");
      exit(0);
    }
  filename= argv[1];

  /* Initialize CPLEX. If a licence is unavailable the
     program waits 5 seconds and asks for licence again. */
  while( !env )
    {
      env=CPXopenCPLEX(&status);
      if( !env )
        {
          printf("CPLEX License unavailable %d... sleeping 5 seconds...\n",
                 status);
          sleep(5);
        }
    }
  status = CPXsetintparam (env, CPX_PARAM_DEPIND, 3);
  if (status)
    {
      fprintf (stderr,
               "Failure to activate dependency checking, error %d.\n", status);
      exit (0);
    }

  /* Stop CPLEX if it has found CPX_PARAM_INTSOLLIM integer solutions */
  status = CPXsetintparam (env, CPX_PARAM_INTSOLLIM, 2);
  if (status)
    {
      fprintf (stderr, "Failed to set the integer solution limit, error code= %d\n", status);
      exit (0);
    }

  /* Stop the optimizers if they have been running for an hour */
  status = CPXsetdblparam (env, CPX_PARAM_TILIM, 3600);
  if (status)
    {
      fprintf (stderr, "Failed to set timelimit, error code= %d\n", status);
      exit (0);
    }

  /* Create LP. */
  lp= NULL;
  lp=CPXcreateprob(env,&status,filename);
  if( status || lp == NULL )
    {
      printf("Could not create lp-problem\n");
      exit(0);
    }

  /* Create object for PMILP. */
  mip= NULL;
  mip=CPXcreateprob(env,&status,filename);
  if( status || lp == NULL )
    {
      printf("Could not create lp-problem\n");
      exit(0);
    }

  /* Read problem into Cplex. */
  CPXreadcopyprob(env,lp,filename, NULL);

  /* Obtain information about the LP. */
  nrow=CPXgetnumrows(env,lp);
  ncol=CPXgetnumcols(env,lp);
  nnz=CPXgetnumnz(env,lp);

  /* Allocating memory for the problem. */
  if( (problem.obj=(double *) malloc((ncol)*sizeof(*problem.obj))) == NULL ||
      (problem.matbeg=(int *) malloc((ncol)*sizeof(*problem.matbeg))) == NULL ||
      (problem.matcnt=(int *) malloc((ncol)*sizeof(*problem.matcnt))) == NULL ||
      (problem.matind=(int *) malloc((nnz)*sizeof(*problem.matind))) == NULL ||
      (problem.matval=
       (double *) malloc((nnz)*sizeof(*problem.matval))) == NULL ||
      (problem.lb=(double *) malloc((ncol)*sizeof(*problem.lb))) == NULL ||
      (problem.ub=(double *) malloc((ncol)*sizeof(*problem.ub))) == NULL ||
      (problem.sense=(char *) malloc((nrow+1)*sizeof(*problem.sense))) == NULL ||
      (problem.ctype=(char *) malloc((ncol+1)*sizeof(*problem.ctype))) == NULL ||
      (problem.rhs=(double *) malloc((nrow)*sizeof(*problem.rhs))) == NULL )
    {
      printf("Memory allocation error\n");
      exit(0);
    }

  /* Obtaining the problem from CPLEX. */
  get_mip_problem(&lp,&env,&problem);

  /* Calculating no. of rows/cols/nnz in PMILP */
  int nrowPmilp = ncol + 1;
  int ncolPmilp = 2*nrow + ncol + 1;
  int nnzPmilp = 2*nnz + ncol + 1;
  /* Taking in to account the extra rows inserted in the A matrix */
  for (i = 0; i < ncol; i++)
    {
      if (problem.lb[i] > -CPX_INFBOUND)
        {
          ncolPmilp += 2;
          nnzPmilp += 4;
        }
      if (problem.ub[i] < CPX_INFBOUND)
        {
          ncolPmilp += 2;
          nnzPmilp += 4;
        }
    }
  for (i = 0; i < nrow; i++)
    {
      if (problem.rhs[i] > ZERO_TOLERANCE ||
          problem.rhs[i] < -ZERO_TOLERANCE)
        nnzPmilp += 2;
    }

  /* Allocating memory for PMILP. */
  if ( (pmilp.matbeg=
        (int *) malloc((ncolPmilp)*sizeof(int))) == NULL ||
       (pmilp.matcnt=
        (int *) malloc((ncolPmilp)*sizeof(int))) == NULL ||
       (pmilp.matind=(int *) malloc((nnzPmilp)*sizeof(int))) == NULL ||
       (pmilp.matval=
        (double *) malloc((nnzPmilp)*sizeof(double))) == NULL ||
       (pmilp.obj = (double *) malloc ((ncolPmilp)*sizeof (double))) == NULL ||
       (pmilp.lb=(double *) malloc((ncolPmilp)*sizeof(double))) == NULL ||
       (pmilp.ub=(double *) malloc((ncolPmilp)*sizeof(double))) == NULL ||
       (pmilp.sense=(char *) malloc((nrowPmilp))) == NULL ||
       (pmilp.ctype=(char *) malloc((ncolPmilp))) == NULL ||
       (pmilp.rhs=(double *) malloc((nrowPmilp)*sizeof(double))) == NULL )
    {
      printf("Memory allocation error\n");
      exit(0);
    }

  /* Allocate memory for solution array and cuts */
  if ((pi =
       (double *) malloc ((ncolPmilp - 2*nrowPmilp - 1) * sizeof (*pi))) == NULL ||
      (cut = (double *) malloc (ncol * sizeof (*cut))) == NULL ||
      (cut_rhs = (double *) malloc (sizeof (*cut_rhs))) == NULL)
    {
      fprintf (stderr, "Memory allocation error!\n");
      exit (0);
    }

  /* Allocate extra memory for lp data of the problem. */
  if( (lp_sol=(double *) malloc(ncol*sizeof(double))) == NULL ||
      (colstat=(int *) malloc(ncol*sizeof(int))) == NULL ||
      (rowstat=(int *) malloc((10000*nrow)*sizeof(int))) == NULL ||
      (objval_pmilp = (double *) malloc (sizeof (*objval_pmilp))) == NULL)
    {
      printf("Memory allocation error\n");
      exit(0);
    }


  /* Setting parameters that are used when allocating memory to the
     cuts structure */
  MAX_NCUTS=MAX_NROW-nrow;
  MAX_NZCUTS=MAX_NZ-nnz;

  /* Feed the problem to CPLEX and solve it */
  copy_and_solve_lp (&env, &lp, &problem, lp_sol, rowstat, colstat, &objval);

  /* Print solution statistics to screen. */
  printf("Problem file          : %s\n", filename);
  printf("Size of LP - columns  : %5d\n", ncol);
  printf("             rows     : %5d\n", nrow);
  printf("             non-zeros: %5d (density: %.2f)\n",
         nnz,(double) 100.0*nnz/(ncol*nrow));
  printf("LP optimal value      : %lf\n\n", objval);

  if (rowstat != NULL)
    free(rowstat);
  if (colstat != NULL)
    free(colstat);
  if (lp_sol != NULL)
    free(lp_sol);
  if (objval_pmilp != NULL)
    free (objval_pmilp);

  /* Construct the basic polyhedron */
  /* construct_basic_polyhedron (&problem,	colstat, rowstat); */

  /* Main loop */
  while (run)
    {
      /* Allocate extra memory for lp data of the problem. */
      if( (lp_sol=(double *) malloc(ncol*sizeof(double))) == NULL ||
          (colstat=(int *) malloc(ncol*sizeof(int))) == NULL ||
          (rowstat=(int *) malloc((10000*nrow)*sizeof(int))) == NULL ||
          (objval_pmilp = (double *) malloc (sizeof (*objval_pmilp))) == NULL)
        {
          printf("Memory allocation error\n");
          exit(0);
        }
      /* Optimize the LP relaxation of the problem. We assume that the
         problem is a minimization type problem. */
      if( CPXlpopt(env, lp)) {
        printf("Failed to optimize LP relaxation\n");
        exit(0);
      }

      /* Get LP solution. */
      if( CPXsolution(env, lp, &status, NULL, lp_sol, NULL, NULL, NULL) ||
          (status != CPX_STAT_OPTIMAL) ) {
        printf("Failed to optimize LP (status=%i)\n", status);
        exit(0);
      }

      /* Obtain the basis. */
      if( CPXgetbase(env, lp, colstat, rowstat) ) {
        printf("Failed to obtain LP solution info\n");
        exit(0);
      }

      /* Calculate the objective value. */
      objval = 0.0;
      for(i = 0; i < problem.ccnt; i++)
        objval = objval + lp_sol[i]*(problem.obj[i]);

      /* Print objective value */
      printf ("LP optimal value      : %lf\n\n", objval);

      /* Allocate memory for the cuts structure */
      if( (cuts.matbeg=(int *) malloc(MAX_NCUTS*sizeof(int))) == NULL ||
          (cuts.matcnt=(int *) malloc(MAX_NCUTS*sizeof(int))) == NULL ||
          (cuts.matind=(int *) malloc(MAX_NZCUTS*sizeof(int))) == NULL ||
          (cuts.matval=(double *) malloc(MAX_NZCUTS*sizeof(double))) == NULL ||
          (cuts.rhs=(double *) malloc(MAX_NCUTS*sizeof(double))) == NULL ||
          (cuts.sense=(char *) malloc(MAX_NCUTS*sizeof(char))) == NULL ) {
        printf("Memory allocation error\n");
        exit(0);
      }
      cuts.rcnt = 0;
      cuts.nzcnt = 0;

      /* Initialize theta, and various counters */
      start = 0.05;
      theta = start;
      count = 0;
      no_grid_enrich = 0;
      grid_interval = 0.05;

      /* For each theta in the grid: Solve the pmilp */
      while (theta < 0.5 + VIOLATION_TOLERANCE)
        {
          /* Compute the value of the constant part of the objective
             function of PMILP */
          constant = 1 - theta;
          constant *= theta;

          /* Construct PMILP */
          construct_pmilp (&problem, &pmilp, theta, lp_sol);

          /* Give PMILP to CPLEX and solve it */
          solstat = copy_and_solve_pmilp (env, mip, &pmilp, theta, pi,
                                          lp_sol, solstat, objval_pmilp);

          if (solstat != 103)
            {
              /* Print the objective value */
              printf ("objval_pmilp= %lf\n", *objval_pmilp - constant);
            }

          /* If CPLEX has not found a feasible solution within an hour then stop */
          if (solstat == 108)
            {
              run = 0;
              exit (0);
            }

          /* Compute the cut and add it to the cuts structure */
          if (solstat != 103 && *objval_pmilp < constant - VIOLATION_TOLERANCE)
            {
              no_grid_enrich = 0;
              /* Generate the cut! */
              compute_split_cut (pi, cut, cut_rhs, &problem,
                                 colstat, rowstat, &env, &lp);
              /* Add the cut to the cuts structure */
              add_cut(&cuts, cut, cut_rhs, ncol);
            }

          /* Update grid_cnt */
          if (theta > (0.5 - grid_interval) && cuts.rcnt == 0)
            {
              theta           = start / 2;
              start           = theta;
              if (count > 0)
                grid_interval = grid_interval / 2;
              count++;
              no_grid_enrich++;
            }
          else
            theta += grid_interval;

          /* If all objvals are >= 0 then stop */
          if (theta > (0.5 - grid_interval) && no_grid_enrich == 20)
            {
              run = 0;
              exit (0);
            }
        }
      /* Add the cuts to the basic polyhedron */
      status = CPXaddrows (env, lp, 0, cuts.rcnt, cuts.nzcnt, cuts.rhs,
                           cuts.sense, cuts.matbeg, cuts.matind, cuts.matval,
                           NULL, NULL);

      /* Free cuts memory */
      if (cuts.matbeg != NULL)
        free(cuts.matbeg);
      if (cuts.matcnt != NULL)
        free(cuts.matcnt);
      if (cuts.matind != NULL)
        free(cuts.matind);
      if (cuts.matval != NULL)
        free(cuts.matval);
      if (cuts.rhs != NULL)
        free(cuts.rhs);
      if (cuts.sense != NULL)
        free(cuts.sense);

      if (rowstat != NULL)
        free(rowstat);
      if (colstat != NULL)
        free(colstat);
      if (lp_sol != NULL)
        free(lp_sol);
      if (objval_pmilp != NULL)
        free (objval_pmilp);

    } /* End of main loop */

  /* Free all lp memory. */
  if ( lp != NULL ) {
    status = CPXfreeprob (env, &lp);
    if ( status )
      fprintf (stderr, "CPXfreeprob failed, error code %d.\n", status);
  }
  if ( mip != NULL ) {
    status = CPXfreeprob (env, &mip);
    if ( status )
      fprintf (stderr, "CPXfreeprob failed, error code %d.\n", status);
  }

  /* Free PROBLEM memory */
  if (problem.obj != NULL)
    free(problem.obj);
  if (problem.matbeg != NULL)
    free(problem.matbeg);
  if (problem.matcnt != NULL)
    free(problem.matcnt);
  if (problem.lb != NULL)
    free(problem.lb);
  if (problem.ub != NULL)
    free(problem.ub);
  if (problem.sense != NULL)
    free(problem.sense);
  if (problem.rhs != NULL)
    free(problem.rhs);
  if (problem.matind != NULL)
    free(problem.matind);
  if (problem.ctype != NULL)
    free(problem.ctype);
  if (problem.matval != NULL)
    free(problem.matval);

  /* Free PMILP memory */
  if (pmilp.obj != NULL)
    free(pmilp.obj);
  if (pmilp.matbeg != NULL)
    free(pmilp.matbeg);
  if (pmilp.matcnt != NULL)
    free(pmilp.matcnt);
  if (pmilp.lb != NULL)
    free(pmilp.lb);
  if (pmilp.ub != NULL)
    free(pmilp.ub);
  if (pmilp.sense != NULL)
    free(pmilp.sense);
  if (pmilp.rhs != NULL)
    free(pmilp.rhs);
  if (pmilp.matind != NULL)
    free(pmilp.matind);
  if (pmilp.ctype != NULL)
    free(pmilp.ctype);
  if (pmilp.matval != NULL)
    free(pmilp.matval);

  if (pi != NULL)
    free (pi);
  if (cut != NULL)
    free (cut);
  if (cut_rhs != NULL)
    free (cut_rhs);

  /* Close CPLEX. */
  if ( env != NULL )
    {
      status = CPXcloseCPLEX (&env);

      /* Note that CPXcloseCPLEX produces no output,
         so the only way to see the cause of the error is to use
         CPXgeterrorstring.  For other CPLEX routines, the errors will
         be seen if the CPX_PARAM_SCRIND indicator is set to CPX_ON. */

      if ( status )
        {
          char  errmsg[1024];
          fprintf (stderr, "Could not close CPLEX environment.\n");
          CPXgeterrorstring (env, status, errmsg);
          fprintf (stderr, "%s", errmsg);
        }
    }
  return 0;
}
